## 1. 프로토타입이란?

- 다른 언어와 달리 자바스크립트에는 ‘클래스’가 없습니다. ES6에서 도입된 클래스는 기존 프로토타입 기반 패턴의 문법적 설탕이라고 볼 수 있습니다.
- 따라서, 자바스크립트의 모든 객체는 자신의 원형이 되는 객체를 가지며, 우리는 이를 ‘프로토타입’이라고 부릅니다.
- 일단 여기까지 알아보고 다음으로 넘어가도록합니다.

<br/>
<br/>

## 2. 프로토타입이 왜 필요할까요?

- 프로토타입을 기반으로 상속을 구현하여 중복을 제거할 수 있습니다.
- 동일한 생성자 함수에 의해 생성된 모든 인스턴스가 동일한 중복 메서드를 소유한다면 어떨까요? 만약 인스턴스가 10000개가 넘어간다면, 자바스크립트는 10000개의 인스턴스마다 각각의 메서드를 위한 메모리 공간을 마련해야 할 것입니다.
- 따라서 자바스크립트는 프로토타입을 통해서 중복된 코드를 제거하여 상속을 구현 할 수 있게 해줍니다.

<br/>
<br/>

## 3. 프로토타입 객체

- 프로토타입 객체(또는 줄여서 프로토타입)란 위에서도 설명했듯, `객체 간 상속`을 구현하기 위해 사용됩니다.
- 따라서 프로토타입은 어떤 객체의 상위(부모) 객체 역할을 하여, 다른 객체에 공유 프로퍼티(메서드 포함)을 제공합니다.
- 프로토타입을 상속받은 하위(자식) 객체는 상위 객체의 프로퍼티를 자신의 프로퍼티처럼 자유롭게 사용 할 수 있습니다.
- 아래 예시를 통해 알아봅시다.

```js
function Person() {}
const JaneDoe = new Person();
```

![](https://i.ibb.co/ykxt4bk/2022-04-17-5-36-28.png)

- 객체 `JaneDoe`의 `__proto__`는 위와 같은 형태를 띕니다.
- 객체는 `new 함수 이름()` 을 통해서 생성 될 수 있습니다.
- `prototype`은 어떤 객체의 원형이 되는 객체를 가리킵니다.
  - JaneDoe 의 prototype 은 Person이 되겠네요!
- `__proto__`는 어떤 객체의 prototype에 접근 할 수 있는 프로퍼티입니다.
  - 자바스크립트는 [[prototype]]이라는 숨김 프로퍼티를 통해서 객체의 prototype을 참조하는데 `__proto__`는 [[prototype]]용 getter/setter에 해당합니다.
- [[prototype]] 이란 내부 슬롯은, 프로토타입의 참조이며, [[Prototype]]에 저장되는 프로토타입은 객체 생성 방식에 의해 결정 됩니다. 즉, 객체가 생성 될 때 생성 방식에 따라 프로토타입이 결정되고, [[prototype]]에 저장됩니다.
  - 객체 리터럴에 의해 생성된 객체의 프로토타입은 `Object.prototype`입니다.
  - 생성자 함수에 의해 생성된 프로토타입은 생성자 함수의 prototype 프로퍼티에 바인딩 되어 있는 객체입니다.
- 모든 객체는 하나의 프로토타입을 가집니다. 그리고 모든 프로토타입은 생성자 함수와 연결되어 있습니다.

이렇게보면 볼 수록 각 프로퍼티들, 즉 `__proto__`가 뭔지, `[[prototype]]`이 뭔지, `prototype`이 뭔지 감이 오지 않습니다. 먼저 이들의 구조를 살펴보고, 프로퍼티를 하나씩 살펴보도록 합니다.

<br/>
<br/>

## 4. Prototype, `__proto__` , Instance 의 구조

- 위에서 살펴봤듯이, 프로토타입 객체란, 어떤 함수로부터 생성된 객체들이 참조하는 객체를 의미합니다.
- 이 때 생성된 프로토타입 객체는 new 생성자로부터 생성된 모든 객체들이 참조하게 됩니다.
- 그러면 함수가 생성될 때 대체 어떤 일이 일어나는 걸까요? 한 단계씩 살펴봅시다.

### 1. 함수에 Constructor 를 부여합니다.

- 생성된 함수에 Constructor 를 부여함으로써 new 키워드를 사용 할 수 있게 해줍니다.
- 따라서 생성된 함수는 다른 객체의 프로토타입이 될 수 있습니다.

### 2. 함수의 프로토타입 객체를 생성하고 연결합니다.

![](https://mooneedev.netlify.app/static/90cb7778800852474dc08b99568fc4b9/ccf45/%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85%EA%B7%B8%EB%A6%BC2.jpg)

- 해당 함수의 프로토타입 객체를 생성하고, 원형 함수 내부의 prototype 속성이 프로토타입 객체를 참조하게 됩니다.
- 참조하는 프로토타입 객체는 new 생성자로부터 생성되는 모든 객체의 원형입니다.
  ![](https://i.ibb.co/XZNzGPS/2022-04-17-6-27-10.png)
- 이렇게 생성된 프로토타입 객체는 `원형함수.prototype` 으로 접근 할 수 있습니다.
- 프로토타입 객체 내부의 `prototype.constructor` 는 원형함수를 참조합니다.
- 따라서 원형 함수와 프로토타입 객체가 서로 연결되게 됩니다.

자, 이제 new 키워드로 인스턴스를 생성하면 어떻게 될까요? new 키워드로 생성된 인스턴스는 어떻게 프로토타입 객체와 연결될까요? 이는 바로 프로토타입 링크를 통해 해결됩니다.

### 3. 프로토타입 링크가 생성됩니다.

- 프로토타입 링크는 new 키워드로 생성된 객체가 자신의 원형 함수.prototype, 즉 프로토타입 객체에 접근할 수 있게 해주는 속성입니다.
  ![](https://mooneedev.netlify.app/static/24fcc63ffd293bf0350f746ca6027a13/8b46b/%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85%EA%B7%B8%EB%A6%BC3.jpg)
- new 키워드로 생성된 객체는 위와 같이 프로토타입 객체를 참조합니다.
- prototype 속성이 원형 함수에만 있었던 것과 달리, `__proto__` 속성은 모든 객체에 존재하므로, 모든 객체는 `__proto__` 속성을 이용해 원형 함수의 프로토타입 객체를 참조할 수 있습니다.

<br/>

따라서, 원형 함수에 생성된 프로토타입 객체에 접근 하는 방법은 두가지가 됩니다.
따라서 생성된 프로토타입 객체에 접근하는 방법은 두가지 이다.

1. 함수의 프로토타입 참조를 타고 간다.
2. 객체의 프로토타입 링크를 타고 간다.

```js
function Person() {} // 함수
const JaneDoe = new Person(); // 객체

Person.prototype; // 첫번째 방법
// 원형 함수의 프로토타입 참조를 타고 갑니다.

JaneDoe.__proto__; // 두번째 방법
// 생성된 객체(인스턴스)의 프로토타입 링크를 타고 갑니다.
```

### 여기서 잠깐! 프로토타입 체인이란?

- 함수 생성시, 생성되는 프로토타입 객체에도 `__proto__` 속성이 존재합니다.
- 이렇게 `__proto__` 에서 또 다시, `__proto__` 로 이어지는 것을 프로토타입 체인이라고 합니다.
  ![](https://mooneedev.netlify.app/static/db9674bb0fafd0094506b4758973cc69/76775/%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85%EA%B5%90%EC%B2%B4.jpg)
  ![](https://i.ibb.co/4PFXZtB/2022-04-17-6-36-36.png)

<br/>
<br/>

## 5. **proto** 프로퍼티

![](https://i.ibb.co/rQZWFvn/2022-04-17-5-59-24.png)

- 모든 객체는 `__proto__` 접근자 프로퍼티를 통해 자신의 프로토타입, 즉 [[prototype]]에 간접적으로 접근 할 수 있다고 위에서 언급했습니다.
- [[prototype]]은 내부슬롯이기 때문에 자바스크립트에서 우리가 직접적으로 접근 할 수는 없습니다.
  - 내부슬롯은 프로퍼티가 아닙니다.
- 따라서, 접근자 프로퍼티 `__proto__` 를 이용해서 내부슬롯 [[prototype]]에 간접적으로 접근해주도록 합니다. -`__proto__`접근자 프로퍼티를 사용하여 프로퍼티를 사용하면, 내부적으로 `__proto__` 접근자 프로퍼티의 getter 함수인 [[Get]] 이 호출됩니다.
- `__proto__` 접근자 프로퍼티를 통해 새로운 프로토타입을 할당하면 `__proto__` 접근자 프로퍼티의 setter 함수인 [[Set]] 이 호출됩니다.

### `__proto__` 접근자 프로퍼티는 상속을 통해 사용됩니다.

- `__proto__` 접근자 프로퍼티는 모든 객체가 직접 소유하는게 아니라 ,Object.prototype의 프로퍼티입니다.
- 모든 객체는 상속을 통해서 `Object.prototype.__proto__` 접근자 프로퍼티를 사용할 수 있습니다.

### 왜 `__proto__` 접근자 프로퍼티가 필요한걸까요?

- 상호참조에 의해 프로토타입 체인이 생성되는 것을 방지하기 위해서입니다.

```js
const parent = {};
const child = {};

child.__proto__ = parent;
parent.__proto__ = child; // TypeError: Cyclick __proto__ value
```

- 프로토타입 체인은 단방향 연결 리스트로 구현되어야 합니다. 따라서 위의 예제와 같이 서로가 자신의 프로토타입이 되는 사이클이 생겨서는 안됩니다.
- 따라서 우리는 `__proto__` 접근자 프로퍼티로 프로토타입 setter 를 관리하여, 아무런 체크 없이 무조건적으로 프로토타입을 교체할 수 없도록 합니다.

### 하지만, `__proto__` 를 직접사용하는 것은 권장하지 않습니다.

```js
cosnt obj = Object.create(null);

console.log(obj.__proto__); // undefined
```

- 위와 같이 직접 상속을 통해 Object.prototype 을 상속받지 않는 객체를 생성할 수도 있기 때문에, `__proto__` 접근자 프로퍼티를 사용 할 수 없는 경우가 있기 때문입니다.
- 따라서, `__proto__` 접근자 프로퍼티 대신, 프로토타입 체인의 참조를 취득하고 싶은 경우에는 `Object.getPrototypeOf`메서드를 권장하고, 프로토타입 교체를 하고 싶은 경우에는 `Object.setPrototype` 메서드를 사용할 것을 권장합니다.

<br/>
<br/>

## 6. 함수 객체의 prototype 프로퍼티

```js
(function () {}).hasOwnProperty("prototype"); // true
({}).hasOwnProperty("prototype"); // false
```

- 함수 객체만 소유하는 prototype 프로퍼티는 생성자 함수가 생성할 인스턴스의 프로토타입을 가리킵니다.
- prototype 프로퍼티는 생성자 함수가 생성할 객체(인스턴스)의 프로토타입을 가리킵니다. 따라서 생성자 함수로서 호출 할 수 없는 함수인 화살표 함수와 ES6의 메서드 축약 표현으로 정의한 메서드는 prototype 프로퍼티를 소유하지 않으며 프로토타입도 생성하지 않습니다.
- 위에서도 살펴보았듯, 결국 모든 객체가 가지고 있는 `__proto__` 접근자 프로퍼티와 함수 객체만 가지고 있는 `prototype`프로퍼티는 동일한 프로토타입 객체를 가리키게 됩니다.

<br/>
<br/>

## 7. 오버라이딩과 프로퍼티 섀도잉

```js
function Person() {}

Person.prototype.sayHello = function () {
  console.log("안녕 나는 호프야");
};

const pobi = new Person();

pobi.sayHello = function () {
  console.log("안녕 나는 포비야");
};

pobi.sayHello(); // 안녕 나는 포비야
```

- 프로토타입이 소유한 프로퍼티(메서드 포함)를 프로토타입 프로퍼티라고 부르고, 인스턴스가 소유한 프로퍼티를 인스턴스 프로퍼티라고 부르겠습니다.
- 프로토타입 프로퍼티와 같은 이름의 프로퍼티를 인스턴스에 추가하면, 프로토타입 체인을 따라 프로토타입 프로퍼티를 덮어쓰는 것이 아니라, 인스턴스 프로퍼티로 추가합니다.
- 이 때 인스턴스 메서드 sayHello 는 프로토타입 메서드 sayHello 를 오버라이딩 했고, 프로토타입 메서드 sayHello는 가려지게 됩니다.
- 이처럼 상속관계에 의해 프로퍼티가 가려지는 현상을 ‘프로퍼티 섀도잉’이라고 합니다.
