# 1. This 가 왜 필요할까?

This 가 무엇이고, 어떻게 사용하는지 살펴보기 전에, This 가 왜 필요한지 알아보도록 합시다.

```javascript
function identify() {
  return this.name;
}

function speak() {
  const greeting = `안녕 나는 ${identify.call(this)}`;
  console.log(greeting);
}

const coach1 = {
  name: "포비",
};

const coach2 = {
  name: "공원",
};

speak.call(coach1); // 안녕 나는 포비
speak.call(coach2); // 안녕 나는 공원
```

- 위와 같은 코드 예시에서, this 를 사용하지 않는다면 일일이 speak 함수에 특정 객체 콘텍스트를 파라미터로 넘겨줘야 합니다. 아래와 같이요!

```javascript
function identify(context){
  return context.name;
}

function speak(context){
  const greeting = `안녕 나는 ${identify(context)}`;
  console.log(greeting);
}

const coach1 = {
  name: "포비";
}

const coach2 = {
  name: "공원";
}

speak(coach1); // 안녕 나는 포비
speak(coach2); // 안녕 나는 공원
```

- 그런데 위의 코드는 사용패턴이 복잡해진다면, 매우 읽기 불편해질 것 같지 않나요? 계속해서 객체를 파라미터로 넘겨주어야 하니까요.
- 따라서, 우리는 this 를 사용하여 이 문제를 해결 할 수 있습니다. 개발자가 직접 함수에게 객체를 전달해주는게 아니라, 함수가 적절한 콘텍스트 객체를 자동 참조하는 구조를 갖게 되니까요.

<br/>
<br/>

# 2. This 란 뭘까?

그렇다면 대체 this 는 무엇일까요? 다른 언어에서의 this 는 대체로 클래스로 생성한 인스턴스 객체를 의미합니다. 따라서 클래스에서만 사용되어서 혼란의 여지가 많이 없어요.
하지만 자바스크립트에서 this 는 클래스 밖 함수에서도 사용되고, 심지어 전역에서도 this 를 참조할 수도 있습니다.
<br/>
This 라는 이름이 많은 혼선을 주기도 합니다. 마치 this 는 함수 자기 자신을 가리키는 것 처럼 생각하게 만들 수도 있겠어요.
그러면 This 가 무엇인지 여러 책에 나온 정의를 정리해보도록 합니다.

<br/>

1. This 는 자신이 속한 객체 또는 자신이 생성할 인스턴스를 가리키는 자기 참조 변수 (self-referencing variable) 이다. 따라서 this 를 통해 자신이 속한 객체 또는 자신이 생성할 인스턴스의 프로퍼티나 메서드를 참조 할 수 있다.
2. This 는 함수와 메서드의 구분이 느슨한 자바스크립트에서 실질적으로 이 둘을 구분해주는 유일한 기능이다.
3. This 는 실제로 함수 호출 시점(런타임)에 결정되며, 무엇을 가리킬지는 전적으로 함수를 호출한 코드에 달렸다.
4. This 는 함수 자신이나 함수의 렉시컬 스코프를 가리키는 레퍼런스가 아니다.
5. This 는 함수가 호출되는 방식에 따라 this에 바인딩 될 값이 동적으로 결정된다.

<br/>

즉 결론적으로 말하자면 아래와 같습니다.

1. This 는 함수 자체를 가리키거나, 함수의 렉시컬 스코프를 가리키지 않습니다.
2. This 는 함수 호출 방식에 따라서 동적으로 결정되기 때문에, 함수 선언 시점에는 this 가 무엇일지 알 수 없습니다.

<br/>

이 쯤에서 시 한편을 보고 갑시다. 이 시는 You Don’t know JS 에 나온 시예요.

```
내가 this 를 호출 하기 전에는
그는 다만
코드 조각에 지나지 않았다.
내가 그를 불러다 쓰려고 할 때
그는 나에게로 와서
바인딩 되었다.
```

이제 this 가 무엇인지 감이 좀 오셨죠?

<br/>
<br/>

# 3. This 바인딩 규칙

위에서 This 는 선언시에 알 수 없으며, 런타임 시에 함수 호출방식에 따라 동적으로 바인딩(결정)된다는 것을 알았습니다. 그러면 어떻게 This 가 바인딩되는지 하나씩 살펴볼까요?

<br/>

## 3-1. 기본 바인딩

- 해당 규칙은 단독 함수 실행에 관한 규칙으로, 앞으로 나올 나머지 규칙에 해당하지 않을 경우에 적용되는 this 의 기본 규칙입니다.

```javascript
function foo() {
  console.log(this.a);
}

var a = 1;
foo(); // 1
```

- **기본 바인딩에서 this 는 전역 객체 (브라우저 - window / Node.js - global) 를 가리킵니다.**
- foo() 함수 호출 시, this.a 는 전역 객체에 저장된 a 를 가리킵니다.
- **엄격 모드(strict mode)에서는 전역 객체가 기본 바인딩 대상에서 제외됩니다. 그래서 this 는 undefined 가 됩니다.**

<br/>

## 3-2. 암시적 바인딩

- 해당 규칙은 호출부에 콘텍스트 객체가 있는지 여부를 확인합니다.
- 즉, ‘.’ 을 사용해서 메서드 형태로 함수를 호출 했는지 확인합니다.

```javascript
function foo() {
  console.log(this.a);
}

var obj = {
  a: 2,
  foo: foo,
};
var a = 1;

foo(); // 1
obj.foo(); // 2
```

- 앞에서 선언된 foo 함수를 obj 객체에서 프로퍼티로 참조하고 있습니다.
- 호출부는 obj 콘텍스트로 foo()를 참조합니다. 즉, foo()의 호출 시점에 이미 obj 참조가 되어있으므로, 암시적 바인딩 규칙에 따라서 해당 콘텍스트 (obj) 객체가 함수 호출시 this 에 바인딩 됩니다.

### 객체 프로퍼티 참조 체이닝의 경우는?

```javascript
function foo() {
  console.log(this.a);
}

var obj2 = {
  a: 42,
  foo: foo,
};

var obj1 = {
  a: 2,
  obj2: obj2,
};

obj1.obj2.foo(); // 42
```

- 위와 같이 체이닝 호출을 할 경우, 중간 단계인 obj1.a 값 2는 무시됩니다.

### 암시적 소실 예제 1

```javascript
function foo() {
  console.log(this.a);
}

var obj = {
  a: 2,
  foo: foo,
};

var bar = obj.foo;
var a = "엥 전역이네~!";

bar(); // 엥 전역이네~!
```

- 위에서, obj.foo를 변수 bar 에 할당 한 후, bar를 실행했더니 foo 에 묶어놨던 obj 참조가 소실되었습니다.
- bar 는 obj의 foo 를 참조하는 변수처럼 보이지만, 실은 bar 역시, foo 를 직접 가리키는 또 다른 레퍼런스가 됩니다.
- 게다가 호출부에서 그냥 평범하게 bar() 를 호출하므로 기본 바인딩이 적용됩니다.

### 암시적 소실 예제 2

```javascript
function foo() {
  console.log(this.a);
}

function doFoo(fn) {
  fn();
}

var obj = {
  a: 2,
  foo: foo,
};

var a = "엥 전역이네~!";

doFoo(obj.foo); // "엥 전역이네~!"
```

- 위의 예시 역시, obj.foo 를 콜백 함수 doFoo 의 인자로 넘겨주었습니다.
- 함수를 인자로 남기면 암시적으로 레퍼런스가 할당되어 이전 예제와 결과가 같게 됩니다.
- 또한 이 역시 콜백 함수 doFoo 에서 평범하게 fn() 를 호출하므로 기본 바인딩이 적용됩니다.

### 콜백 함수 호출 시 그 함수 내부에서의 this 바인딩

- 콜백 함수는 함수 A (콜백함수)의 제어권을 다른 함수 B에게 넘겨주는 경우를 말합니다.
- 이 때 함수 A 는 함수 B의 내부 로직에 따라 실행되며, this 역시 함수 B 내부 로직에서 정한 규칙에 따라 값이 결정 됩니다.
- 콜백 함수도 함수이기 때문에 기본적으로 this 가 전역 객체를 참조하겠지만, 제어권을 받은 함수에서 별도에 this 가 될 대상이 지정된 경우에는 그 대상을 참조하게 됩니다.

### 화살표 함수

- ES6에 새롭게 도입된 화살표 함수는 실행 컨텍스트 생성 시 this 를 바인딩 하는 과정이 제외되었습니다.
- 즉 화살표 함수 내부에는 this 가 아예 없으며, 접근하고자 한다면 스코프 체인상 가장 가까운 this 에 접근하게 됩니다.
- 즉 따로 명시적으로 this 바인딩을 해주지 않아도, 상위 스코프의 this를 사용 할 수 있습니다.

<br/>

## 3-4. 명시적 바인딩

- 위에서 살펴본 암시적 바인딩은 함수 참조 프로퍼티에 객체를 직접 더하여 (obj.foo) this 를 바인딩했습니다. 콜백함수 역시 암시적으로 콜백함수를 제어하는 함수에게 this 바인딩 권한이 넘어갔습니다. 그렇다면, 함수 참조 프로퍼티에 객체를 직접 더하거나 콜백함수를 사용하지 않고 어떤 객체를 this 바인딩에 이용하겠다고 자바스크립트에게 알려줄 수 있을까요?
- 바로 `call(), apply(), bind()` 메서드를 사용 할 수 있습니다.
- 해당 메서드들은 this 를 바인딩 할 객체를 첫째 인자로 받아, 함수 호출시 이 객체를 this 로 지정해줍니다.
- 즉, this 를 개발자가 직접 정할 수 있으므로 우리는 이를 `명시적 바인딩`이라고 부를 수 있습니다.

```javascript
function foo() {
  console.log(this.a);
}

var obj = {
  a: 2,
};

foo.call(obj); //2
```

- 만약 call 메서드의 첫번째 인자에 객체가 아니라 단순한 원시값을 인자로 전달하면 어떻게 될까요?
  > 원시값에 대응되는 객체 (문자열 - new String(), 불리언 - new Boolean(), 숫자 - new Number() ) 로 랩핑되어 전달됩니다.

<br/>

## 3-5. New 바인딩

- 자바스크립트에서의 생성자란, 앞에 new 연산자가 있을 때 호출되는 일반 함수입니다.
- 함수 앞에 new 를 붙여 생성자 호출을 하면 아래와 같은 일들이 일어납니다.

1. 새 객체가 만들어 집니다.
2. 새로 생성된 객체의 [[Prototype]]이 연결 됩니다.
3. 새로 생성된 객체는 해당 함수 호출 시, this 로 바인딩 됩니다.
4. 이 함수가 자신의 또 다른 객체를 반환하지 않는 한, new 와 함께 호출된 함수는 자동으로 새로 생성된 객체를 반환합니다. (인스턴스 반환)

- 즉,생성자 함수로서 호출 된 경우 내부에서의 this 는 곧 새로 만들 구체적인 인스턴스 자신이 됩니다.

<br/>
<br/>

# 4. This 바인딩 우선순위

지금까지 this 바인딩의 여러 규칙을 살펴봤습니다. 그런데 만약 여러개의 규칙이 중복으로 해당할 땐 어떻게 될까요? 그래서 자바스크립트는 우선순위를 정해놨습니다.

결론적으로 말하자면 아래와 같은 우선순위를 가집니다.

```
1. New 바인딩
2. 명시적 바인딩
3. 암시적 바인딩
```

- 왜냐하면 명시적 바인딩은 어떤 종류든 자체 this 바인딩을 무시하고 주어진 바인딩을 적용하여 하드 코딩된 새로운 함수를 생성하기 때문입니다. (Bind 메서드)
