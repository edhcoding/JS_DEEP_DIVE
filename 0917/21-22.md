# 21 빌트인 객체

## 21.1 자바스크립트객체의분류

- **표준 빌트인 객체**
  : 자바스크립트 엔진에 내장되어 있는 객체
  Array, Object, Function, Date 등
- **호스트 객체**
  : 자바스크립트 환경(브라우저, Node.js 등)에 의해 제공되는 객체
  브라우저에서는 `window`, `document`, `XMLHttpRequest` 등
- **사용자 정의 객체**
  : 개발자가 필요에 따라 직접 정의한 객체
  사용자 정의 함수나 클래스 등을 통해 생성한 객체들

## 21.2 표준 빌트인 객체

자바스크립트는 Object, String, Number, Boolean, Symbol, Date, Math, RegExp, Array, Map/Set, WeakMap/WeakSet, Function, Promise, Reflect, Proxy, JSON, Error 등 40여 개의 표준 빌트인 객체를 제공한다.

Math, Reflect, JSON을 제외한 표준 빌트인 객체는 모두 **인스턴스를 생성할 수 있는 생성자 함수 객체**다.

생성자 함수 객체인 표준 빌트인 객체는 **프로토타입 메서드와 정적 메서드**를 제공하고, 생성자 함수 객체가 아닌 표준 빌트인 객체는 **정적 메서드**만 제공한다.

## 21.3 원시값과 래퍼 객체

Q. 원시값이 있는데도 문자열, 숫자, 불리언 객체를 생성하는 String, Number, Boolean 등의 표준 빌트인 생성자 함수가 존재하는 이유?

자바스크립트에서는 원시값에도 메서드를 호출할 수 있도록 **일시적으로 래퍼 객체를 생성**한다.

```jsx
// 문자열 원시값 "hello"가 일시적으로 String 객체로 변환
// toUpperCase() 메서드를 사용

const str = "hello";
console.log(str.toUpperCase()); // "HELLO"
```

## 21.4 전역 객체

코드가 실행되기 이전, 자바스크립트 엔진에 의해 어떤 객체보다도 먼저 생성되는 특수한 객체

어떤 객체에도 속하지 않은 최상위 객체

### 21.4.1 빌트인 전역 프로퍼티

: 전역 객체의 **프로퍼티**를 의미

- **Infinity**: 무한대를 나타내는 숫자 값
- **NaN**: 숫자가 아님을 나타내는 값
- **undefined**: 값이 할당되지 않은 변수의 기본 값

### 21.4.2 빌트인 전역 함수

: 전역 객체의 **메서드**

- **eval()**: 문자열로 표현된 자바스크립트 코드를 실행
- **isFinite()**: 전달된 값이 유한수인지 검사
- **isNaN()**: 전달된 값이 NaN인지 검사
- **parseFloat()**: 문자열을 부동소수점 숫자로 변환
- **parseInt()**: 문자열을 정수로 변환

### 21.4.3 암묵적 전역

: 변수를 선언할 때 `var`, `let`, `const` 키워드를 사용하지 않고 선언하면 전역 객체의 프로퍼티로 추가되는 것을 의미

```jsx
function foo() {
  y = 20; // window.y = 20;
}
foo();

console.log(y); // 20
```

# 22 this

## 22.1 this 키워드

: 자신이 속한 객체 또는 자신이 생성할 인스턴스를 가리키는 자기 참조 변수.

프로퍼티나 메서드를 참조 할 수 있다.

this의 바인딩은 함수 호출 방식에 의해 **`동적`**으로 결정된다.

+) Strict mode가 적용된 일반 함수 내부의 this에는 undefined가 바인딩된다.

## 22.2 함수 호출 방식과 this 바인딩

<aside>
💡 렉시컬 스코프와 this 바인딩은 결정 시기가 다르다.

함수의 상위 스코프를 결정하는 방식인 렉시컬 스코프(lexical scope)는 함수 정의가 평가되어 **`함수 객체가 생성되는 시점`**에 상위 스코프를 결정한다. 하지만 this 바인딩은 **`함수 호출 시점`**에 결정된다.

</aside>

### 22.2.1 일반 함수 호출

기본적으로 this에는 **`전역 객체`**가 바인딩된다.

```jsx
function foo() {
  console.log(this); // window
}
foo();
// strict mode 에서는 undefined로 바인딩
```

일반 함수로 호출된 모든 함수(중첩 함수, **콜백 함수** 포함) 내부의 this에는 **전역 객체**가 바인딩된다.

화살표 함수 내부의 this는 상위 스코프의 this를 가리킨다.

```jsx
var value = 1;
const obj = {
  value: 100,
  foo() {
    // 화살표 함수 내부의 this는 상위 스코프의 this를 가리킨다.
    setTimeout(() => console.log(this.value), 100); // 100
  },
};

obj.foo();
```

### 22.2.2 메서드 호출

메서드로 호출된 함수 내부의 this는 메서드를 **호출한 객체**, 즉 메서드 호출 시점에 **`점(.) 앞의 객체가 바인딩`**된다.

```jsx
const person = {
  name: "Lee",
  getName() {
    // 메서드 내부의 this는 호출한 객체에 바인딩
    return this.name;
  },
};

console.log(person.getName()); // Lee

// getName을 다른 객체의 프로퍼티에 할당하기
const anotherPerson = {
  name: "Kim",
};

// getName 메서드를 anotherPerson 객체의 메서드로할당
anotherPerson.getName = person.getName;

// getName 메서드를 **호출한 객체는 anotherPerson**이다.
console.log(anotherPerson.getName()); // Kim
```

호출 시점에 this에 객체가 바인딩 되는것을 확인 할 수 있다.

![Untitled](20,%2021,%2022%20691ebad9b3b7450bbd4f01971cab3481/Untitled.png)

### 22.2.3 생성자 함수 호출

생성자 함수 내부의 this는 생성자 함수가 **`생성할 인스턴스`**가 바인딩된다.

```jsx
function Person(name) {
  this.name = name;
}

const person1 = new Person("Bob");

console.log(person1.name); // 'Bob'
```

### 22.2.4 Function.prototype.apply/call/bind 메서드에 의한 간접 호출

Function.prototype의 **메서드 -** `apply, call, bind`

this를 명시적으로 호출 할 수 있다.

메서드에 **`첫번째 인수로 전달한 객체`**가 바인딩된다.

- **apply**: 함수 인수를 배열로 받는다.
- **call**: 함수 인수를 개별적으로 받는다.
- **bind**: 함수의 this 값을 영구히 바인딩하며, 새로운 함수를 반환한다.

```jsx
function greet(greeting, punctuation) {
  console.log(greeting + ", " + this.name + punctuation);
}

const person = { name: "Carol" };

// apply: 함수 인수를 배열로 받는다
greet.apply(person, ["Hello", "!"]); // 'Hello, Carol!'

// call: 함수 인수를 개별적으로 받는다
greet.call(person, "Hi", "?"); // 'Hi, Carol?'

// bind: 함수의 this 값을 **영구히 바인딩**하며, 새로운 함수를 반환한다
const boundGreet = greet.bind(person, "Hey");
boundGreet("."); // 'Hey, Carol.'
```

### bind 추가 예시

```jsx
const module = {
  x: 42,
  getX: function () {
    return this.x;
  },
};

const unboundGetX = module.getX;
console.log(unboundGetX()); // undefined, 함수가 전역 컨텍스트에서 호출되었기 때문에

const boundGetX = unboundGetX.bind(module);
console.log(boundGetX()); // 42, this가 module 객체로 바인딩되었기 때문에
```

### 이벤트 핸들러에서 this 바인딩

```jsx
function Button(label) {
  this.label = label;
}

Button.prototype.click = function () {
  console.log(this.label + " button clicked");
};

const button = new Button("Submit");
const buttonElement = document.getElementById("myButton");
buttonElement.addEventListener("click", button.click.bind(button)); // this를 button 인스턴스로 고정
```
